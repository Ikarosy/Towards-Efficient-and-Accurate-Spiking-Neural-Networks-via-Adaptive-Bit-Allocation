\section{Preliminaries}
\label{sec:preliminaries}

\paragraph{Multi-bit spiking neuron.}
Here, we first formulate the conventional LIF model in the discrete form:
\begin{align}
    &v^t_l=
    \begin{cases}\frac{1}{\tau}v^{t-1}_l+ V^t_{in,l}, S^{t-1}_{out,l}=0\\v_{rst},\text{otherwise}
    \end{cases}\label{eq:lif1}\\
&S^t_{out,l}=\begin{cases}1, v^t> V_{th} \\0, \text{otherwise}
\end{cases}\label{eq:lif2}
\end{align}
where $v^t_l$ denotes the membrane potential at time-step $t$ in the layer $l$ and can be updated with  \cref{eq:lif1}. $v_{rst}$ and $\tau$, respectively representing the resting potential and the time coefficient, are  constants. $V_{in,l}^t$, representing the input current, is a variable. In  \cref{eq:lif2}, $S^t_{out,l}$ is the binary spike whose value is determined by whether the membrane potential $v^t_l$ exceeds the potential threshold $V_{th}$. If that happened, $v^t_l$ w would also be reset to $v_{rst}$.
Plus, the input current $V_{in,l}^t$ is calculated from  the previous layer's $S^t_{out,l-1}$ via $V_{in,l}^t=\sum_jw_{l-1}S_{out,l}^t$, where $w_{l-1}$ denotes the weight parameters and $j$ denotes
the index of  spiking neurons.

Rooted from burst encoding \cite{liefficient}, multi-bit spiking neuron generalizes  \cref{eq:lif2} to allow multiple spikes at the same time step. The formulation transforms into \cite{shen2024conventional,xiao2024multi,xing2024spikellm}:
\begin{align}
     &V_{in,l}^t=\sum_j( w_{l-1}\cdot \alpha)S_{l-1}^t,\label{eq:mlif1}\\
&v^t_l=\frac{1}{\tau}v_l^{t-1}+ V^t_{in,l} - \alpha \cdot S^{t-1}_{out,l},\label{eq:mlif2}
\\
&S^t_{out,l}=floor(\frac{v^t_l}{V_{th}}).\label{eq:mlif3}
\end{align}
Here, $floor(x)$ is the flooring function, and $\alpha$ is the spike amplitude coefficient.
With such transformation, the representation space of spiking neuron is increased to $S^t_{out}\in \{0,1,..,2^{B_s}-1\}^T$. $B_s$ and $T$ denote the spike bit width and the temporal length, respectively.
\\\textbf{Legitimate computation and memory measurement.}
Shen \etal \cite{shen2024conventional} shed light on the chaotic overhead measurement used in the prior arts, and propose the “Bit Budget” paradigm to fairly and practically estimate the substantial computation and memory. Following is the definition:
\begin{align}
    \text{Bit budget (BB)} = T \cdot B_{w} \cdot B_{s},\label{eq:bit budget}
\end{align}
where $B_{w}$ denotes the weight bit width. And, the corresponding  computational expenses evaluation, named Arithmetic Computation Effort (S-ACE), is defined by:
\begin{align}
    \text{S-ACE} = \sum_{w\in W, s\in S} n_{w,s}\cdot \text{BB} .\label{eq:sace}
\end{align}
$n_{w,s}$ is multiply-accumulate operations' number (MACs), $W$ and $S$ are weights and spikes' sets, respectively.  


